<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="TE-edge">
    <meta name="description" content="this website will help you to learn programming and be professional">
    <title>learn programming</title>
    <link rel="stylesheet" href="article.css">
    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
</head>

<body> 
     <h1>Let's learn programming<h1>
        <p><b>   <font  size="4"> For our first lesson, we will make Three.js works the most straightforward way: no bundler, no dependency, no modules, just an HTML file, and some JavaScript. </font>   </p> 
        
        
            <h2><b><font  size="6">How to use Three.js</font></h2> 
            <p><b><font  size="4"> Inside of our script.js file, we now have access to a variable named THREE. Be careful and always write it using uppercase.

                If you console.log() this variable, you'll see that there is a lot going on inside:
                
                console.log(THREE)
                The THREE variable contains most of the classes and properties you might need on a classic Three.js project. Unfortunately, not all classes are inside this variable, but we will see later how to access them.
                
                To use one of those classes, you need to instantiate it. For example, if you want to create a scene, you'll write const scene = new THREE.Scene(). If you want to create a sphere geometry, you need to write const sphereGeometry = new THREE.SphereGeometry(1.5, 32, 32) —We'll dig deeper into these later. </font> </p>
        
        
            <h2><b><font  size="6">objects</font></h2>
            <p><b><font  size="4"> Objects can be many things. You can have primitive geometries, imported models, particles, lights, and so on.

                We will start with a simple red cube.
                
                To create that red cube, we need to create a type of object named Mesh. A Mesh is the combination of a geometry (the shape) and a material (how it looks).
                
                There are many geometries and many materials, but we will keep things simple for now and create a BoxGeometry and a MeshBasicMaterial.
                
                To create the geometry, we use the BoxGeometry class with the first 3 parameters that correspond to the box's size.To create the material, we use the MeshBasicMaterial class with one parameter: an object {} containing all the options. All we need is to specify its color property.

                There are many ways to specify a color in Three.js. You can send it as a JS hexadecimal 0xff0000, you can send it as a string hexadecimal '#ff0000', you can use color names like 'red', or you can send an instance of the Color class —we'll cover more about it later.
                
                
                                 
            </font></p>
        
        
            <h2><b><font  size="6">Camera  </font> </h2> 
        
            <p><b><font  size="4">The camera is not visible. It's more like a theoretical point of view. When we will do a render of your scene, it will be from that camera's point of view.

                You can have multiple cameras just like on a movie set, and you can switch between those cameras as you please. Usually, we only use one camera.
                
                There are different types of cameras, and we will talk about these in a future lesson. For now, we simply need a camera that handles perspective (making close objects look more prominent than far objects).
                
                To create the camera, we use the PerspectiveCamera class.
                
                There are two essential parameters we need to provide.
                
                The field of view
                
                The field of view is how large your vision angle is. If you use a very large angle, you'll be able to see in every direction at once but with much distortion, because the result will be drawn on a small rectangle. If you use a small angle, things will look zoomed in. The field of view (or fov) is expressed in degrees and corresponds to the vertical vision angle. For this exercise we will use a 75 degrees angle.</font></p>
                <h2><b><font  size="6"> Renderer</font> </h2>
                    <p><b><font  size="4">The renderer's job is to do the render. Bet you didn't see that coming?

                        We will simply ask the renderer to render our scene from the camera point of view, and the result will be drawn into a canvas. You can create the canvas by yourself, or let the renderer generate it and then add it to your page. For this exercise, we will add the canvas to the html and send it to the renderer.
                        
                        Create the  element before you load the scripts and give it a class:
                                               
                        To create the renderer, we use the WebGLRenderer class with one parameter: an object {} containing all the options. We need to specify the canvas property corresponding to the  we added to the page.
                        
                        Create a canvas variable at the start of the code, then fetch and store in it the element we created in the HTML using document.querySelector(...).
                        
                        It's better to assign the canvas to a variable because we'll use it for other purposes in the next lessons.
                        
                        We also need to update the size of your renderer with the setSize(...) method using the sizes object we created earlier. The setSize(...) method will automatically resize our  accordingly:</font><p>
                            <h2><b><font  size="6">First render </font> </h2>
                                <p><b><font  size="4"> It's time to work on our first render. Call the render(...) method on the renderer and send it the scene and the camera as parameters:

                                    renderer.render(scene, camera)
                                    Still nothing? Here's the issue: we haven't specified our object's position, nor our camera's. Both are in the default position, which is the center of the scene and we can't see an object from its inside (by default).
                                    
                                    We need to move things.
                                    
                                    To do that, we have access to multiple properties on each object, such as position, rotation, and scale. For now, use the position property to move the camera backward.
                                    
                                    The position property is an object with three relevant properties: x, y and z. By default, Three.js considers the forward/backward axis to be z.
                                    
                                    To move the camera backward, we need to provide a positive value to that property. You can do that anywhere once you've created the camera variable, yet it has to happen before you do the render: </font>
                                    <h2><b><font  size="6">Finally </font> </h2>
                                        <p><b><font  size="4"> Congratulations, you should see your first render. It looks like a square, and that's because the camera aligns perfectly with the cube, and you can see only one side of it.</font><p>
            </body>
            </html>